import Foundation
import Prch

public enum Campaigns {}
public enum Templates {}
public enum Lists {}
public enum Reports {}
public enum Root {}
public enum SearchCampaigns {}
public enum SearchMembers {}
public enum TemplateFolders {}

public enum ActivityFeed {}
public enum AuthorizedApps {}
public enum Automations {}
public enum BatchWebhooks {}
public enum Batches {}
public enum CampaignFolders {}
public enum ConnectedSites {}
public enum Conversations {}
public enum CustomerJourneys {}
public enum Ecommerce {}
public enum FacebookAds {}
public enum FileManager {}
public enum LandingPages {}
public enum Ping {}
public enum Reporting {}
public enum VerifiedDomains {}

/** An error generated by the Mailchimp API. Conforms to IETF draft 'draft-nottingham-http-problem-06'. */
public struct DefaultResponse: Model {
  /** A human-readable explanation specific to this occurrence of the problem. [Learn more about errors](/developer/guides/get-started-with-mailchimp-api-3/#Errors). */
  public var detail: String

  /** A string that identifies this specific occurrence of the problem. Please provide this ID when contacting support. */
  public var instance: String

  /** The HTTP status code (RFC2616, Section 6) generated by the origin server for this occurrence of the problem. */
  public var status: Int

  /** A short, human-readable summary of the problem type. It shouldn't change based on the occurrence of the problem, except for purposes of localization. */
  public var title: String

  /** An absolute URI that identifies the problem type. When dereferenced, it should provide human-readable documentation for the problem type. */
  public var type: String

  public init(detail: String, instance: String, status: Int, title: String, type: String) {
    self.detail = detail
    self.instance = instance
    self.status = status
    self.title = title
    self.type = type
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: StringCodingKey.self)

    detail = try container.decode("detail")
    instance = try container.decode("instance")
    status = try container.decode("status")
    title = try container.decode("title")
    type = try container.decode("type")
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: StringCodingKey.self)

    try container.encode(detail, forKey: "detail")
    try container.encode(instance, forKey: "instance")
    try container.encode(status, forKey: "status")
    try container.encode(title, forKey: "title")
    try container.encode(type, forKey: "type")
  }
}

/** This object represents a link from the resource where it is found to another resource or action that may be performed. */
public struct Links: Model {
  /** The HTTP method that should be used when accessing the URL defined in 'href'. */
  public enum Method: String, Codable, Equatable, CaseIterable {
    case get = "GET"
    case post = "POST"
    case put = "PUT"
    case patch = "PATCH"
    case delete = "DELETE"
    case options = "OPTIONS"
    case head = "HEAD"
  }

  /** This property contains a fully-qualified URL that can be called to retrieve the linked resource or perform the linked action. */
  public var href: String?

  /** The HTTP method that should be used when accessing the URL defined in 'href'. */
  public var method: Method?

  /** As with an HTML 'rel' attribute, this describes the type of link. */
  public var rel: String?

  /** For HTTP methods that can receive bodies (POST and PUT), this is a URL representing the schema that the body should conform to. */
  public var schema: String?

  /** For GETs, this is a URL representing the schema that the response should conform to. */
  public var targetSchema: String?

  public init(href: String? = nil, method: Method? = nil, rel: String? = nil, schema: String? = nil, targetSchema: String? = nil) {
    self.href = href
    self.method = method
    self.rel = rel
    self.schema = schema
    self.targetSchema = targetSchema
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: StringCodingKey.self)

    href = try container.decodeIfPresent("href")
    method = try container.decodeIfPresent("method")
    rel = try container.decodeIfPresent("rel")
    schema = try container.decodeIfPresent("schema")
    targetSchema = try container.decodeIfPresent("targetSchema")
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: StringCodingKey.self)

    try container.encodeIfPresent(href, forKey: "href")
    try container.encodeIfPresent(method, forKey: "method")
    try container.encodeIfPresent(rel, forKey: "rel")
    try container.encodeIfPresent(schema, forKey: "schema")
    try container.encodeIfPresent(targetSchema, forKey: "targetSchema")
  }
}
