//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension API.Automations {

    /**
    Add automation

    Create a new classic automation in your Mailchimp account.
    */
    public enum PostAutomations {

        public static let service = APIService<Response>(id: "postAutomations", tag: "automations", method: "POST", path: "/automations", hasBody: true, securityRequirements: [SecurityRequirement(type: "basicAuth", scopes: [])])

        public final class Request: APIRequest<Response> {

            /** A summary of an individual Automation workflow's settings and content. */
            public class Body: APIModel {

                /** List settings for the Automation. */
                public var recipients: Recipients

                /** Trigger settings for the Automation. */
                public var triggerSettings: TriggerSettings

                /** The settings for the Automation workflow. */
                public var settings: Settings?

                /** List settings for the Automation. */
                public class Recipients: APIModel {

                    /** The id of the List. */
                    public var listId: String?

                    /** The id of the store. */
                    public var storeId: String?

                    public init(listId: String? = nil, storeId: String? = nil) {
                        self.listId = listId
                        self.storeId = storeId
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        listId = try container.decodeIfPresent("list_id")
                        storeId = try container.decodeIfPresent("store_id")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(listId, forKey: "list_id")
                        try container.encodeIfPresent(storeId, forKey: "store_id")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Recipients else { return false }
                      guard self.listId == object.listId else { return false }
                      guard self.storeId == object.storeId else { return false }
                      return true
                    }

                    public static func == (lhs: Recipients, rhs: Recipients) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** Trigger settings for the Automation. */
                public class TriggerSettings: APIModel {

                    /** The type of Automation workflow. Currently only supports 'abandonedCart'. */
                    public var workflowType: String

                    public init(workflowType: String) {
                        self.workflowType = workflowType
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        workflowType = try container.decode("workflow_type")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encode(workflowType, forKey: "workflow_type")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? TriggerSettings else { return false }
                      guard self.workflowType == object.workflowType else { return false }
                      return true
                    }

                    public static func == (lhs: TriggerSettings, rhs: TriggerSettings) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** The settings for the Automation workflow. */
                public class Settings: APIModel {

                    /** The 'from' name for the Automation (not an email address). */
                    public var fromName: String?

                    /** The reply-to email address for the Automation. */
                    public var replyTo: String?

                    public init(fromName: String? = nil, replyTo: String? = nil) {
                        self.fromName = fromName
                        self.replyTo = replyTo
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        fromName = try container.decodeIfPresent("from_name")
                        replyTo = try container.decodeIfPresent("reply_to")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(fromName, forKey: "from_name")
                        try container.encodeIfPresent(replyTo, forKey: "reply_to")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Settings else { return false }
                      guard self.fromName == object.fromName else { return false }
                      guard self.replyTo == object.replyTo else { return false }
                      return true
                    }

                    public static func == (lhs: Settings, rhs: Settings) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(recipients: Recipients, triggerSettings: TriggerSettings, settings: Settings? = nil) {
                    self.recipients = recipients
                    self.triggerSettings = triggerSettings
                    self.settings = settings
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    recipients = try container.decode("recipients")
                    triggerSettings = try container.decode("trigger_settings")
                    settings = try container.decodeIfPresent("settings")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(recipients, forKey: "recipients")
                    try container.encode(triggerSettings, forKey: "trigger_settings")
                    try container.encodeIfPresent(settings, forKey: "settings")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Body else { return false }
                  guard self.recipients == object.recipients else { return false }
                  guard self.triggerSettings == object.triggerSettings else { return false }
                  guard self.settings == object.settings else { return false }
                  return true
                }

                public static func == (lhs: Body, rhs: Body) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            public var body: Body

            public init(body: Body, encoder: RequestEncoder? = nil) {
                self.body = body
                super.init(service: PostAutomations.service) { defaultEncoder in
                    return try (encoder ?? defaultEncoder).encode(body)
                }
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** A summary of an individual Automation workflow's settings and content. */
            public class Status200: APIModel {

                /** The current status of the Automation. */
                public enum Status: String, Codable, Equatable, CaseIterable {
                    case save = "save"
                    case paused = "paused"
                    case sending = "sending"
                }

                /** A list of link types and descriptions for the API schema documents. */
                public var links: [Links]?

                /** The date and time the Automation was created in ISO 8601 format. */
                public var createTime: DateTime?

                /** The total number of emails sent for the Automation. */
                public var emailsSent: Int?

                /** A string that identifies the Automation. */
                public var id: String?

                /** List settings for the Automation. */
                public var recipients: Recipients?

                /** A summary of opens and clicks for sent campaigns. */
                public var reportSummary: ReportSummary?

                /** The settings for the Automation workflow. */
                public var settings: Settings?

                /** The date and time the Automation was started in ISO 8601 format. */
                public var startTime: DateTime?

                /** The current status of the Automation. */
                public var status: Status?

                /** The tracking options for the Automation. */
                public var tracking: Tracking?

                /** Available triggers for Automation workflows. */
                public var triggerSettings: TriggerSettings?

                /** This object represents a link from the resource where it is found to another resource or action that may be performed. */
                public class Links: APIModel {

                    /** The HTTP method that should be used when accessing the URL defined in 'href'. */
                    public enum Method: String, Codable, Equatable, CaseIterable {
                        case get = "GET"
                        case post = "POST"
                        case put = "PUT"
                        case patch = "PATCH"
                        case delete = "DELETE"
                        case options = "OPTIONS"
                        case head = "HEAD"
                    }

                    /** This property contains a fully-qualified URL that can be called to retrieve the linked resource or perform the linked action. */
                    public var href: String?

                    /** The HTTP method that should be used when accessing the URL defined in 'href'. */
                    public var method: Method?

                    /** As with an HTML 'rel' attribute, this describes the type of link. */
                    public var rel: String?

                    /** For HTTP methods that can receive bodies (POST and PUT), this is a URL representing the schema that the body should conform to. */
                    public var schema: String?

                    /** For GETs, this is a URL representing the schema that the response should conform to. */
                    public var targetSchema: String?

                    public init(href: String? = nil, method: Method? = nil, rel: String? = nil, schema: String? = nil, targetSchema: String? = nil) {
                        self.href = href
                        self.method = method
                        self.rel = rel
                        self.schema = schema
                        self.targetSchema = targetSchema
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        href = try container.decodeIfPresent("href")
                        method = try container.decodeIfPresent("method")
                        rel = try container.decodeIfPresent("rel")
                        schema = try container.decodeIfPresent("schema")
                        targetSchema = try container.decodeIfPresent("targetSchema")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(href, forKey: "href")
                        try container.encodeIfPresent(method, forKey: "method")
                        try container.encodeIfPresent(rel, forKey: "rel")
                        try container.encodeIfPresent(schema, forKey: "schema")
                        try container.encodeIfPresent(targetSchema, forKey: "targetSchema")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Links else { return false }
                      guard self.href == object.href else { return false }
                      guard self.method == object.method else { return false }
                      guard self.rel == object.rel else { return false }
                      guard self.schema == object.schema else { return false }
                      guard self.targetSchema == object.targetSchema else { return false }
                      return true
                    }

                    public static func == (lhs: Links, rhs: Links) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** List settings for the Automation. */
                public class Recipients: APIModel {

                    /** The unique list id. */
                    public var listId: String?

                    /** The status of the list used, namely if it's deleted or disabled. */
                    public var listIsActive: Bool?

                    /** List Name. */
                    public var listName: String?

                    /** An object representing all segmentation options. */
                    public var segmentOpts: SegmentOpts?

                    /** The id of the store. */
                    public var storeId: String?

                    /** An object representing all segmentation options. */
                    public class SegmentOpts: APIModel {

                        /** Segment match type. */
                        public enum Match: String, Codable, Equatable, CaseIterable {
                            case any = "any"
                            case all = "all"
                        }

                        /** Segment match conditions. There are multiple possible types, see the [condition types documentation](https://mailchimp.com/developer/marketing/docs/alternative-schemas/#segment-condition-schemas). */
                        public var conditions: [[String: Any]]?

                        /** Segment match type. */
                        public var match: Match?

                        /** The id for an existing saved segment. */
                        public var savedSegmentId: Int?

                        public init(conditions: [[String: Any]]? = nil, match: Match? = nil, savedSegmentId: Int? = nil) {
                            self.conditions = conditions
                            self.match = match
                            self.savedSegmentId = savedSegmentId
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            conditions = try container.decodeAnyIfPresent("conditions")
                            match = try container.decodeIfPresent("match")
                            savedSegmentId = try container.decodeIfPresent("saved_segment_id")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeAnyIfPresent(conditions, forKey: "conditions")
                            try container.encodeIfPresent(match, forKey: "match")
                            try container.encodeIfPresent(savedSegmentId, forKey: "saved_segment_id")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? SegmentOpts else { return false }
                          guard self.conditions == object.conditions else { return false }
                          guard self.match == object.match else { return false }
                          guard self.savedSegmentId == object.savedSegmentId else { return false }
                          return true
                        }

                        public static func == (lhs: SegmentOpts, rhs: SegmentOpts) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    public init(listId: String? = nil, listIsActive: Bool? = nil, listName: String? = nil, segmentOpts: SegmentOpts? = nil, storeId: String? = nil) {
                        self.listId = listId
                        self.listIsActive = listIsActive
                        self.listName = listName
                        self.segmentOpts = segmentOpts
                        self.storeId = storeId
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        listId = try container.decodeIfPresent("list_id")
                        listIsActive = try container.decodeIfPresent("list_is_active")
                        listName = try container.decodeIfPresent("list_name")
                        segmentOpts = try container.decodeIfPresent("segment_opts")
                        storeId = try container.decodeIfPresent("store_id")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(listId, forKey: "list_id")
                        try container.encodeIfPresent(listIsActive, forKey: "list_is_active")
                        try container.encodeIfPresent(listName, forKey: "list_name")
                        try container.encodeIfPresent(segmentOpts, forKey: "segment_opts")
                        try container.encodeIfPresent(storeId, forKey: "store_id")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Recipients else { return false }
                      guard self.listId == object.listId else { return false }
                      guard self.listIsActive == object.listIsActive else { return false }
                      guard self.listName == object.listName else { return false }
                      guard self.segmentOpts == object.segmentOpts else { return false }
                      guard self.storeId == object.storeId else { return false }
                      return true
                    }

                    public static func == (lhs: Recipients, rhs: Recipients) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** A summary of opens and clicks for sent campaigns. */
                public class ReportSummary: APIModel {

                    /** The number of unique clicks, divided by the total number of successful deliveries. */
                    public var clickRate: Double?

                    /** The total number of clicks for an campaign. */
                    public var clicks: Int?

                    /** The number of unique opens divided by the total number of successful deliveries. */
                    public var openRate: Double?

                    /** The total number of opens for a campaign. */
                    public var opens: Int?

                    /** The number of unique clicks. */
                    public var subscriberClicks: Int?

                    /** The number of unique opens. */
                    public var uniqueOpens: Int?

                    public init(clickRate: Double? = nil, clicks: Int? = nil, openRate: Double? = nil, opens: Int? = nil, subscriberClicks: Int? = nil, uniqueOpens: Int? = nil) {
                        self.clickRate = clickRate
                        self.clicks = clicks
                        self.openRate = openRate
                        self.opens = opens
                        self.subscriberClicks = subscriberClicks
                        self.uniqueOpens = uniqueOpens
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        clickRate = try container.decodeIfPresent("click_rate")
                        clicks = try container.decodeIfPresent("clicks")
                        openRate = try container.decodeIfPresent("open_rate")
                        opens = try container.decodeIfPresent("opens")
                        subscriberClicks = try container.decodeIfPresent("subscriber_clicks")
                        uniqueOpens = try container.decodeIfPresent("unique_opens")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(clickRate, forKey: "click_rate")
                        try container.encodeIfPresent(clicks, forKey: "clicks")
                        try container.encodeIfPresent(openRate, forKey: "open_rate")
                        try container.encodeIfPresent(opens, forKey: "opens")
                        try container.encodeIfPresent(subscriberClicks, forKey: "subscriber_clicks")
                        try container.encodeIfPresent(uniqueOpens, forKey: "unique_opens")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? ReportSummary else { return false }
                      guard self.clickRate == object.clickRate else { return false }
                      guard self.clicks == object.clicks else { return false }
                      guard self.openRate == object.openRate else { return false }
                      guard self.opens == object.opens else { return false }
                      guard self.subscriberClicks == object.subscriberClicks else { return false }
                      guard self.uniqueOpens == object.uniqueOpens else { return false }
                      return true
                    }

                    public static func == (lhs: ReportSummary, rhs: ReportSummary) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** The settings for the Automation workflow. */
                public class Settings: APIModel {

                    /** Whether Mailchimp [authenticated](https://mailchimp.com/help/about-email-authentication/) the Automation. Defaults to `true`. */
                    public var authenticate: Bool?

                    /** Whether to automatically append Mailchimp's [default footer](https://mailchimp.com/help/about-campaign-footers/) to the Automation. */
                    public var autoFooter: Bool?

                    /** The 'from' name for the Automation (not an email address). */
                    public var fromName: String?

                    /** Whether to automatically inline the CSS included with the Automation content. */
                    public var inlineCss: Bool?

                    /** The reply-to email address for the Automation. */
                    public var replyTo: String?

                    /** The title of the Automation. */
                    public var title: String?

                    /** The Automation's custom 'To' name, typically the first name [audience field](https://mailchimp.com/help/getting-started-with-merge-tags/). */
                    public var toName: String?

                    /** Whether to use Mailchimp Conversation feature to manage replies */
                    public var useConversation: Bool?

                    public init(authenticate: Bool? = nil, autoFooter: Bool? = nil, fromName: String? = nil, inlineCss: Bool? = nil, replyTo: String? = nil, title: String? = nil, toName: String? = nil, useConversation: Bool? = nil) {
                        self.authenticate = authenticate
                        self.autoFooter = autoFooter
                        self.fromName = fromName
                        self.inlineCss = inlineCss
                        self.replyTo = replyTo
                        self.title = title
                        self.toName = toName
                        self.useConversation = useConversation
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        authenticate = try container.decodeIfPresent("authenticate")
                        autoFooter = try container.decodeIfPresent("auto_footer")
                        fromName = try container.decodeIfPresent("from_name")
                        inlineCss = try container.decodeIfPresent("inline_css")
                        replyTo = try container.decodeIfPresent("reply_to")
                        title = try container.decodeIfPresent("title")
                        toName = try container.decodeIfPresent("to_name")
                        useConversation = try container.decodeIfPresent("use_conversation")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(authenticate, forKey: "authenticate")
                        try container.encodeIfPresent(autoFooter, forKey: "auto_footer")
                        try container.encodeIfPresent(fromName, forKey: "from_name")
                        try container.encodeIfPresent(inlineCss, forKey: "inline_css")
                        try container.encodeIfPresent(replyTo, forKey: "reply_to")
                        try container.encodeIfPresent(title, forKey: "title")
                        try container.encodeIfPresent(toName, forKey: "to_name")
                        try container.encodeIfPresent(useConversation, forKey: "use_conversation")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Settings else { return false }
                      guard self.authenticate == object.authenticate else { return false }
                      guard self.autoFooter == object.autoFooter else { return false }
                      guard self.fromName == object.fromName else { return false }
                      guard self.inlineCss == object.inlineCss else { return false }
                      guard self.replyTo == object.replyTo else { return false }
                      guard self.title == object.title else { return false }
                      guard self.toName == object.toName else { return false }
                      guard self.useConversation == object.useConversation else { return false }
                      return true
                    }

                    public static func == (lhs: Settings, rhs: Settings) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** The tracking options for the Automation. */
                public class Tracking: APIModel {

                    /** Deprecated */
                    public var capsule: Capsule?

                    /** The custom slug for [ClickTale](https://mailchimp.com/help/additional-tracking-options-for-campaigns/) tracking (max of 50 bytes). */
                    public var clicktale: String?

                    /** Whether to enable e-commerce tracking. */
                    public var ecomm360: Bool?

                    /** Deprecated */
                    public var goalTracking: Bool?

                    /** The custom slug for [Google Analytics](https://mailchimp.com/help/integrate-google-analytics-with-mailchimp/) tracking (max of 50 bytes). */
                    public var googleAnalytics: String?

                    /** Whether to [track clicks](https://mailchimp.com/help/enable-and-view-click-tracking/) in the HTML version of the Automation. Defaults to `true`. */
                    public var htmlClicks: Bool?

                    /** Whether to [track opens](https://mailchimp.com/help/about-open-tracking/). Defaults to `true`. */
                    public var opens: Bool?

                    /** Deprecated */
                    public var salesforce: Salesforce?

                    /** Whether to [track clicks](https://mailchimp.com/help/enable-and-view-click-tracking/) in the plain-text version of the Automation. Defaults to `true`. */
                    public var textClicks: Bool?

                    /** Deprecated */
                    public class Capsule: APIModel {

                        /** Update contact notes for a campaign based on a subscriber's email addresses. */
                        public var notes: Bool?

                        public init(notes: Bool? = nil) {
                            self.notes = notes
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            notes = try container.decodeIfPresent("notes")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(notes, forKey: "notes")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Capsule else { return false }
                          guard self.notes == object.notes else { return false }
                          return true
                        }

                        public static func == (lhs: Capsule, rhs: Capsule) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    /** Deprecated */
                    public class Salesforce: APIModel {

                        /** Create a campaign in a connected Salesforce account. */
                        public var campaign: Bool?

                        /** Update contact notes for a campaign based on a subscriber's email address. */
                        public var notes: Bool?

                        public init(campaign: Bool? = nil, notes: Bool? = nil) {
                            self.campaign = campaign
                            self.notes = notes
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            campaign = try container.decodeIfPresent("campaign")
                            notes = try container.decodeIfPresent("notes")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(campaign, forKey: "campaign")
                            try container.encodeIfPresent(notes, forKey: "notes")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Salesforce else { return false }
                          guard self.campaign == object.campaign else { return false }
                          guard self.notes == object.notes else { return false }
                          return true
                        }

                        public static func == (lhs: Salesforce, rhs: Salesforce) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    public init(capsule: Capsule? = nil, clicktale: String? = nil, ecomm360: Bool? = nil, goalTracking: Bool? = nil, googleAnalytics: String? = nil, htmlClicks: Bool? = nil, opens: Bool? = nil, salesforce: Salesforce? = nil, textClicks: Bool? = nil) {
                        self.capsule = capsule
                        self.clicktale = clicktale
                        self.ecomm360 = ecomm360
                        self.goalTracking = goalTracking
                        self.googleAnalytics = googleAnalytics
                        self.htmlClicks = htmlClicks
                        self.opens = opens
                        self.salesforce = salesforce
                        self.textClicks = textClicks
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        capsule = try container.decodeIfPresent("capsule")
                        clicktale = try container.decodeIfPresent("clicktale")
                        ecomm360 = try container.decodeIfPresent("ecomm360")
                        goalTracking = try container.decodeIfPresent("goal_tracking")
                        googleAnalytics = try container.decodeIfPresent("google_analytics")
                        htmlClicks = try container.decodeIfPresent("html_clicks")
                        opens = try container.decodeIfPresent("opens")
                        salesforce = try container.decodeIfPresent("salesforce")
                        textClicks = try container.decodeIfPresent("text_clicks")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(capsule, forKey: "capsule")
                        try container.encodeIfPresent(clicktale, forKey: "clicktale")
                        try container.encodeIfPresent(ecomm360, forKey: "ecomm360")
                        try container.encodeIfPresent(goalTracking, forKey: "goal_tracking")
                        try container.encodeIfPresent(googleAnalytics, forKey: "google_analytics")
                        try container.encodeIfPresent(htmlClicks, forKey: "html_clicks")
                        try container.encodeIfPresent(opens, forKey: "opens")
                        try container.encodeIfPresent(salesforce, forKey: "salesforce")
                        try container.encodeIfPresent(textClicks, forKey: "text_clicks")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Tracking else { return false }
                      guard self.capsule == object.capsule else { return false }
                      guard self.clicktale == object.clicktale else { return false }
                      guard self.ecomm360 == object.ecomm360 else { return false }
                      guard self.goalTracking == object.goalTracking else { return false }
                      guard self.googleAnalytics == object.googleAnalytics else { return false }
                      guard self.htmlClicks == object.htmlClicks else { return false }
                      guard self.opens == object.opens else { return false }
                      guard self.salesforce == object.salesforce else { return false }
                      guard self.textClicks == object.textClicks else { return false }
                      return true
                    }

                    public static func == (lhs: Tracking, rhs: Tracking) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** Available triggers for Automation workflows. */
                public class TriggerSettings: APIModel {

                    /** The type of Automation workflow. */
                    public enum WorkflowType: String, Codable, Equatable, CaseIterable {
                        case abandonedBrowse = "abandonedBrowse"
                        case abandonedCart = "abandonedCart"
                        case api = "api"
                        case bestCustomers = "bestCustomers"
                        case categoryFollowup = "categoryFollowup"
                        case dateAdded = "dateAdded"
                        case emailFollowup = "emailFollowup"
                        case emailSeries = "emailSeries"
                        case groupAdd = "groupAdd"
                        case groupRemove = "groupRemove"
                        case mandrill = "mandrill"
                        case productFollowup = "productFollowup"
                        case purchaseFollowup = "purchaseFollowup"
                        case recurringEvent = "recurringEvent"
                        case specialEvent = "specialEvent"
                        case visitUrl = "visitUrl"
                        case welcomeSeries = "welcomeSeries"
                    }

                    /** The type of Automation workflow. */
                    public var workflowType: WorkflowType

                    /** A workflow's runtime settings for an Automation. */
                    public var runtime: Runtime?

                    /** The number of emails in the Automation workflow. */
                    public var workflowEmailsCount: Int?

                    /** The title of the workflow type. */
                    public var workflowTitle: String?

                    /** A workflow's runtime settings for an Automation. */
                    public class Runtime: APIModel {

                        /** The days an Automation workflow can send. */
                        public enum Days: String, Codable, Equatable, CaseIterable {
                            case sunday = "sunday"
                            case monday = "monday"
                            case tuesday = "tuesday"
                            case wednesday = "wednesday"
                            case thursday = "thursday"
                            case friday = "friday"
                            case saturday = "saturday"
                        }

                        /** The days an Automation workflow can send. */
                        public var days: [Days]?

                        /** The hours an Automation workflow can send. */
                        public var hours: Hours?

                        /** The hours an Automation workflow can send. */
                        public class Hours: APIModel {

                            /** When to send the Automation email. */
                            public enum `Type`: String, Codable, Equatable, CaseIterable {
                                case sendAsap = "send_asap"
                                case sendBetween = "send_between"
                                case sendAt = "send_at"
                            }

                            /** When to send the Automation email. */
                            public var type: `Type`

                            public init(type: `Type`) {
                                self.type = type
                            }

                            public required init(from decoder: Decoder) throws {
                                let container = try decoder.container(keyedBy: StringCodingKey.self)

                                type = try container.decode("type")
                            }

                            public func encode(to encoder: Encoder) throws {
                                var container = encoder.container(keyedBy: StringCodingKey.self)

                                try container.encode(type, forKey: "type")
                            }

                            public func isEqual(to object: Any?) -> Bool {
                              guard let object = object as? Hours else { return false }
                              guard self.type == object.type else { return false }
                              return true
                            }

                            public static func == (lhs: Hours, rhs: Hours) -> Bool {
                                return lhs.isEqual(to: rhs)
                            }
                        }

                        public init(days: [Days]? = nil, hours: Hours? = nil) {
                            self.days = days
                            self.hours = hours
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            days = try container.decodeArrayIfPresent("days")
                            hours = try container.decodeIfPresent("hours")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(days, forKey: "days")
                            try container.encodeIfPresent(hours, forKey: "hours")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Runtime else { return false }
                          guard self.days == object.days else { return false }
                          guard self.hours == object.hours else { return false }
                          return true
                        }

                        public static func == (lhs: Runtime, rhs: Runtime) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    public init(workflowType: WorkflowType, runtime: Runtime? = nil, workflowEmailsCount: Int? = nil, workflowTitle: String? = nil) {
                        self.workflowType = workflowType
                        self.runtime = runtime
                        self.workflowEmailsCount = workflowEmailsCount
                        self.workflowTitle = workflowTitle
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        workflowType = try container.decode("workflow_type")
                        runtime = try container.decodeIfPresent("runtime")
                        workflowEmailsCount = try container.decodeIfPresent("workflow_emails_count")
                        workflowTitle = try container.decodeIfPresent("workflow_title")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encode(workflowType, forKey: "workflow_type")
                        try container.encodeIfPresent(runtime, forKey: "runtime")
                        try container.encodeIfPresent(workflowEmailsCount, forKey: "workflow_emails_count")
                        try container.encodeIfPresent(workflowTitle, forKey: "workflow_title")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? TriggerSettings else { return false }
                      guard self.workflowType == object.workflowType else { return false }
                      guard self.runtime == object.runtime else { return false }
                      guard self.workflowEmailsCount == object.workflowEmailsCount else { return false }
                      guard self.workflowTitle == object.workflowTitle else { return false }
                      return true
                    }

                    public static func == (lhs: TriggerSettings, rhs: TriggerSettings) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(links: [Links]? = nil, createTime: DateTime? = nil, emailsSent: Int? = nil, id: String? = nil, recipients: Recipients? = nil, reportSummary: ReportSummary? = nil, settings: Settings? = nil, startTime: DateTime? = nil, status: Status? = nil, tracking: Tracking? = nil, triggerSettings: TriggerSettings? = nil) {
                    self.links = links
                    self.createTime = createTime
                    self.emailsSent = emailsSent
                    self.id = id
                    self.recipients = recipients
                    self.reportSummary = reportSummary
                    self.settings = settings
                    self.startTime = startTime
                    self.status = status
                    self.tracking = tracking
                    self.triggerSettings = triggerSettings
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    links = try container.decodeArrayIfPresent("_links")
                    createTime = try container.decodeIfPresent("create_time")
                    emailsSent = try container.decodeIfPresent("emails_sent")
                    id = try container.decodeIfPresent("id")
                    recipients = try container.decodeIfPresent("recipients")
                    reportSummary = try container.decodeIfPresent("report_summary")
                    settings = try container.decodeIfPresent("settings")
                    startTime = try container.decodeIfPresent("start_time")
                    status = try container.decodeIfPresent("status")
                    tracking = try container.decodeIfPresent("tracking")
                    triggerSettings = try container.decodeIfPresent("trigger_settings")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(links, forKey: "_links")
                    try container.encodeIfPresent(createTime, forKey: "create_time")
                    try container.encodeIfPresent(emailsSent, forKey: "emails_sent")
                    try container.encodeIfPresent(id, forKey: "id")
                    try container.encodeIfPresent(recipients, forKey: "recipients")
                    try container.encodeIfPresent(reportSummary, forKey: "report_summary")
                    try container.encodeIfPresent(settings, forKey: "settings")
                    try container.encodeIfPresent(startTime, forKey: "start_time")
                    try container.encodeIfPresent(status, forKey: "status")
                    try container.encodeIfPresent(tracking, forKey: "tracking")
                    try container.encodeIfPresent(triggerSettings, forKey: "trigger_settings")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.links == object.links else { return false }
                  guard self.createTime == object.createTime else { return false }
                  guard self.emailsSent == object.emailsSent else { return false }
                  guard self.id == object.id else { return false }
                  guard self.recipients == object.recipients else { return false }
                  guard self.reportSummary == object.reportSummary else { return false }
                  guard self.settings == object.settings else { return false }
                  guard self.startTime == object.startTime else { return false }
                  guard self.status == object.status else { return false }
                  guard self.tracking == object.tracking else { return false }
                  guard self.triggerSettings == object.triggerSettings else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** An error generated by the Mailchimp API. Conforms to IETF draft 'draft-nottingham-http-problem-06'. */
            public class DefaultResponse: APIModel {

                /** A human-readable explanation specific to this occurrence of the problem. [Learn more about errors](/developer/guides/get-started-with-mailchimp-api-3/#Errors). */
                public var detail: String

                /** A string that identifies this specific occurrence of the problem. Please provide this ID when contacting support. */
                public var instance: String

                /** The HTTP status code (RFC2616, Section 6) generated by the origin server for this occurrence of the problem. */
                public var status: Int

                /** A short, human-readable summary of the problem type. It shouldn't change based on the occurrence of the problem, except for purposes of localization. */
                public var title: String

                /** An absolute URI that identifies the problem type. When dereferenced, it should provide human-readable documentation for the problem type. */
                public var type: String

                public init(detail: String, instance: String, status: Int, title: String, type: String) {
                    self.detail = detail
                    self.instance = instance
                    self.status = status
                    self.title = title
                    self.type = type
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    detail = try container.decode("detail")
                    instance = try container.decode("instance")
                    status = try container.decode("status")
                    title = try container.decode("title")
                    type = try container.decode("type")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(detail, forKey: "detail")
                    try container.encode(instance, forKey: "instance")
                    try container.encode(status, forKey: "status")
                    try container.encode(title, forKey: "title")
                    try container.encode(type, forKey: "type")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? DefaultResponse else { return false }
                  guard self.detail == object.detail else { return false }
                  guard self.instance == object.instance else { return false }
                  guard self.status == object.status else { return false }
                  guard self.title == object.title else { return false }
                  guard self.type == object.type else { return false }
                  return true
                }

                public static func == (lhs: DefaultResponse, rhs: DefaultResponse) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200
            case status200(Status200)

            /** An error generated by the Mailchimp API. */
            case defaultResponse(statusCode: Int, DefaultResponse)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                default: return nil
                }
            }

            public var failure: DefaultResponse? {
                switch self {
                case .defaultResponse(_, let response): return response
                default: return nil
                }
            }

            /// either success or failure value. Success is anything in the 200..<300 status code range
            public var responseResult: APIResponseResult<Status200, DefaultResponse> {
                if let successValue = success {
                    return .success(successValue)
                } else if let failureValue = failure {
                    return .failure(failureValue)
                } else {
                    fatalError("Response does not have success or failure response")
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                case .defaultResponse(_, let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                case .defaultResponse(let statusCode, _): return statusCode
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                case .defaultResponse: return false
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                default: self = try .defaultResponse(statusCode: statusCode, decoder.decode(DefaultResponse.self, from: data))
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
