//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

extension API.Automations {

    /**
    List automations

    Get a summary of an account's classic automations.
    */
    public enum GetAutomations {

        public static let service = APIService<Response>(id: "getAutomations", tag: "automations", method: "GET", path: "/automations", hasBody: false, securityRequirements: [SecurityRequirement(type: "basicAuth", scopes: [])])

        /** Restrict the results to automations with the specified status. */
        public enum Status: String, Codable, Equatable, CaseIterable {
            case save = "save"
            case paused = "paused"
            case sending = "sending"
        }

        public final class Request: APIRequest<Response> {

            public struct Options {

                /** The number of records to return. Default value is 10. Maximum value is 1000 */
                public var count: Int?

                /** Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0. */
                public var offset: Int?

                /** A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation. */
                public var fields: [String]?

                /** A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation. */
                public var excludeFields: [String]?

                /** Restrict the response to automations created before this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00. */
                public var beforeCreateTime: DateTime?

                /** Restrict the response to automations created after this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00. */
                public var sinceCreateTime: DateTime?

                /** Restrict the response to automations started before this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00. */
                public var beforeStartTime: DateTime?

                /** Restrict the response to automations started after this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00. */
                public var sinceStartTime: DateTime?

                /** Restrict the results to automations with the specified status. */
                public var status: Status?

                public init(count: Int? = nil, offset: Int? = nil, fields: [String]? = nil, excludeFields: [String]? = nil, beforeCreateTime: DateTime? = nil, sinceCreateTime: DateTime? = nil, beforeStartTime: DateTime? = nil, sinceStartTime: DateTime? = nil, status: Status? = nil) {
                    self.count = count
                    self.offset = offset
                    self.fields = fields
                    self.excludeFields = excludeFields
                    self.beforeCreateTime = beforeCreateTime
                    self.sinceCreateTime = sinceCreateTime
                    self.beforeStartTime = beforeStartTime
                    self.sinceStartTime = sinceStartTime
                    self.status = status
                }
            }

            public var options: Options

            public init(options: Options) {
                self.options = options
                super.init(service: GetAutomations.service)
            }

            /// convenience initialiser so an Option doesn't have to be created
            public convenience init(count: Int? = nil, offset: Int? = nil, fields: [String]? = nil, excludeFields: [String]? = nil, beforeCreateTime: DateTime? = nil, sinceCreateTime: DateTime? = nil, beforeStartTime: DateTime? = nil, sinceStartTime: DateTime? = nil, status: Status? = nil) {
                let options = Options(count: count, offset: offset, fields: fields, excludeFields: excludeFields, beforeCreateTime: beforeCreateTime, sinceCreateTime: sinceCreateTime, beforeStartTime: beforeStartTime, sinceStartTime: sinceStartTime, status: status)
                self.init(options: options)
            }

            public override var queryParameters: [String: Any] {
                var params: [String: Any] = [:]
                if let count = options.count {
                  params["count"] = count
                }
                if let offset = options.offset {
                  params["offset"] = offset
                }
                if let fields = options.fields?.joined(separator: ",") {
                  params["fields"] = fields
                }
                if let excludeFields = options.excludeFields?.joined(separator: ",") {
                  params["exclude_fields"] = excludeFields
                }
                if let beforeCreateTime = options.beforeCreateTime?.encode() {
                  params["before_create_time"] = beforeCreateTime
                }
                if let sinceCreateTime = options.sinceCreateTime?.encode() {
                  params["since_create_time"] = sinceCreateTime
                }
                if let beforeStartTime = options.beforeStartTime?.encode() {
                  params["before_start_time"] = beforeStartTime
                }
                if let sinceStartTime = options.sinceStartTime?.encode() {
                  params["since_start_time"] = sinceStartTime
                }
                if let status = options.status?.encode() {
                  params["status"] = status
                }
                return params
            }
        }

        public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {

            /** An array of objects, each representing an Automation workflow. */
            public class Status200: APIModel {

                /** A list of link types and descriptions for the API schema documents. */
                public var links: [Links]?

                /** An array of objects, each representing an Automation workflow. */
                public var automations: [Automations]?

                /** The total number of items matching the query regardless of pagination. */
                public var totalItems: Int?

                /** This object represents a link from the resource where it is found to another resource or action that may be performed. */
                public class Links: APIModel {

                    /** The HTTP method that should be used when accessing the URL defined in 'href'. */
                    public enum Method: String, Codable, Equatable, CaseIterable {
                        case get = "GET"
                        case post = "POST"
                        case put = "PUT"
                        case patch = "PATCH"
                        case delete = "DELETE"
                        case options = "OPTIONS"
                        case head = "HEAD"
                    }

                    /** This property contains a fully-qualified URL that can be called to retrieve the linked resource or perform the linked action. */
                    public var href: String?

                    /** The HTTP method that should be used when accessing the URL defined in 'href'. */
                    public var method: Method?

                    /** As with an HTML 'rel' attribute, this describes the type of link. */
                    public var rel: String?

                    /** For HTTP methods that can receive bodies (POST and PUT), this is a URL representing the schema that the body should conform to. */
                    public var schema: String?

                    /** For GETs, this is a URL representing the schema that the response should conform to. */
                    public var targetSchema: String?

                    public init(href: String? = nil, method: Method? = nil, rel: String? = nil, schema: String? = nil, targetSchema: String? = nil) {
                        self.href = href
                        self.method = method
                        self.rel = rel
                        self.schema = schema
                        self.targetSchema = targetSchema
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        href = try container.decodeIfPresent("href")
                        method = try container.decodeIfPresent("method")
                        rel = try container.decodeIfPresent("rel")
                        schema = try container.decodeIfPresent("schema")
                        targetSchema = try container.decodeIfPresent("targetSchema")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(href, forKey: "href")
                        try container.encodeIfPresent(method, forKey: "method")
                        try container.encodeIfPresent(rel, forKey: "rel")
                        try container.encodeIfPresent(schema, forKey: "schema")
                        try container.encodeIfPresent(targetSchema, forKey: "targetSchema")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Links else { return false }
                      guard self.href == object.href else { return false }
                      guard self.method == object.method else { return false }
                      guard self.rel == object.rel else { return false }
                      guard self.schema == object.schema else { return false }
                      guard self.targetSchema == object.targetSchema else { return false }
                      return true
                    }

                    public static func == (lhs: Links, rhs: Links) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                /** A summary of an individual Automation workflow's settings and content. */
                public class Automations: APIModel {

                    /** The current status of the Automation. */
                    public enum Status: String, Codable, Equatable, CaseIterable {
                        case save = "save"
                        case paused = "paused"
                        case sending = "sending"
                    }

                    /** A list of link types and descriptions for the API schema documents. */
                    public var links: [Links]?

                    /** The date and time the Automation was created in ISO 8601 format. */
                    public var createTime: DateTime?

                    /** The total number of emails sent for the Automation. */
                    public var emailsSent: Int?

                    /** A string that identifies the Automation. */
                    public var id: String?

                    /** List settings for the Automation. */
                    public var recipients: Recipients?

                    /** A summary of opens and clicks for sent campaigns. */
                    public var reportSummary: ReportSummary?

                    /** The settings for the Automation workflow. */
                    public var settings: Settings?

                    /** The date and time the Automation was started in ISO 8601 format. */
                    public var startTime: DateTime?

                    /** The current status of the Automation. */
                    public var status: Status?

                    /** The tracking options for the Automation. */
                    public var tracking: Tracking?

                    /** Available triggers for Automation workflows. */
                    public var triggerSettings: TriggerSettings?

                    /** This object represents a link from the resource where it is found to another resource or action that may be performed. */
                    public class Links: APIModel {

                        /** The HTTP method that should be used when accessing the URL defined in 'href'. */
                        public enum Method: String, Codable, Equatable, CaseIterable {
                            case get = "GET"
                            case post = "POST"
                            case put = "PUT"
                            case patch = "PATCH"
                            case delete = "DELETE"
                            case options = "OPTIONS"
                            case head = "HEAD"
                        }

                        /** This property contains a fully-qualified URL that can be called to retrieve the linked resource or perform the linked action. */
                        public var href: String?

                        /** The HTTP method that should be used when accessing the URL defined in 'href'. */
                        public var method: Method?

                        /** As with an HTML 'rel' attribute, this describes the type of link. */
                        public var rel: String?

                        /** For HTTP methods that can receive bodies (POST and PUT), this is a URL representing the schema that the body should conform to. */
                        public var schema: String?

                        /** For GETs, this is a URL representing the schema that the response should conform to. */
                        public var targetSchema: String?

                        public init(href: String? = nil, method: Method? = nil, rel: String? = nil, schema: String? = nil, targetSchema: String? = nil) {
                            self.href = href
                            self.method = method
                            self.rel = rel
                            self.schema = schema
                            self.targetSchema = targetSchema
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            href = try container.decodeIfPresent("href")
                            method = try container.decodeIfPresent("method")
                            rel = try container.decodeIfPresent("rel")
                            schema = try container.decodeIfPresent("schema")
                            targetSchema = try container.decodeIfPresent("targetSchema")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(href, forKey: "href")
                            try container.encodeIfPresent(method, forKey: "method")
                            try container.encodeIfPresent(rel, forKey: "rel")
                            try container.encodeIfPresent(schema, forKey: "schema")
                            try container.encodeIfPresent(targetSchema, forKey: "targetSchema")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Links else { return false }
                          guard self.href == object.href else { return false }
                          guard self.method == object.method else { return false }
                          guard self.rel == object.rel else { return false }
                          guard self.schema == object.schema else { return false }
                          guard self.targetSchema == object.targetSchema else { return false }
                          return true
                        }

                        public static func == (lhs: Links, rhs: Links) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    /** List settings for the Automation. */
                    public class Recipients: APIModel {

                        /** The unique list id. */
                        public var listId: String?

                        /** The status of the list used, namely if it's deleted or disabled. */
                        public var listIsActive: Bool?

                        /** List Name. */
                        public var listName: String?

                        /** An object representing all segmentation options. */
                        public var segmentOpts: SegmentOpts?

                        /** The id of the store. */
                        public var storeId: String?

                        /** An object representing all segmentation options. */
                        public class SegmentOpts: APIModel {

                            /** Segment match type. */
                            public enum Match: String, Codable, Equatable, CaseIterable {
                                case any = "any"
                                case all = "all"
                            }

                            /** Segment match conditions. There are multiple possible types, see the [condition types documentation](https://mailchimp.com/developer/marketing/docs/alternative-schemas/#segment-condition-schemas). */
                            public var conditions: [[String: Any]]?

                            /** Segment match type. */
                            public var match: Match?

                            /** The id for an existing saved segment. */
                            public var savedSegmentId: Int?

                            public init(conditions: [[String: Any]]? = nil, match: Match? = nil, savedSegmentId: Int? = nil) {
                                self.conditions = conditions
                                self.match = match
                                self.savedSegmentId = savedSegmentId
                            }

                            public required init(from decoder: Decoder) throws {
                                let container = try decoder.container(keyedBy: StringCodingKey.self)

                                conditions = try container.decodeAnyIfPresent("conditions")
                                match = try container.decodeIfPresent("match")
                                savedSegmentId = try container.decodeIfPresent("saved_segment_id")
                            }

                            public func encode(to encoder: Encoder) throws {
                                var container = encoder.container(keyedBy: StringCodingKey.self)

                                try container.encodeAnyIfPresent(conditions, forKey: "conditions")
                                try container.encodeIfPresent(match, forKey: "match")
                                try container.encodeIfPresent(savedSegmentId, forKey: "saved_segment_id")
                            }

                            public func isEqual(to object: Any?) -> Bool {
                              guard let object = object as? SegmentOpts else { return false }
                              guard self.conditions == object.conditions else { return false }
                              guard self.match == object.match else { return false }
                              guard self.savedSegmentId == object.savedSegmentId else { return false }
                              return true
                            }

                            public static func == (lhs: SegmentOpts, rhs: SegmentOpts) -> Bool {
                                return lhs.isEqual(to: rhs)
                            }
                        }

                        public init(listId: String? = nil, listIsActive: Bool? = nil, listName: String? = nil, segmentOpts: SegmentOpts? = nil, storeId: String? = nil) {
                            self.listId = listId
                            self.listIsActive = listIsActive
                            self.listName = listName
                            self.segmentOpts = segmentOpts
                            self.storeId = storeId
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            listId = try container.decodeIfPresent("list_id")
                            listIsActive = try container.decodeIfPresent("list_is_active")
                            listName = try container.decodeIfPresent("list_name")
                            segmentOpts = try container.decodeIfPresent("segment_opts")
                            storeId = try container.decodeIfPresent("store_id")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(listId, forKey: "list_id")
                            try container.encodeIfPresent(listIsActive, forKey: "list_is_active")
                            try container.encodeIfPresent(listName, forKey: "list_name")
                            try container.encodeIfPresent(segmentOpts, forKey: "segment_opts")
                            try container.encodeIfPresent(storeId, forKey: "store_id")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Recipients else { return false }
                          guard self.listId == object.listId else { return false }
                          guard self.listIsActive == object.listIsActive else { return false }
                          guard self.listName == object.listName else { return false }
                          guard self.segmentOpts == object.segmentOpts else { return false }
                          guard self.storeId == object.storeId else { return false }
                          return true
                        }

                        public static func == (lhs: Recipients, rhs: Recipients) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    /** A summary of opens and clicks for sent campaigns. */
                    public class ReportSummary: APIModel {

                        /** The number of unique clicks, divided by the total number of successful deliveries. */
                        public var clickRate: Double?

                        /** The total number of clicks for an campaign. */
                        public var clicks: Int?

                        /** The number of unique opens divided by the total number of successful deliveries. */
                        public var openRate: Double?

                        /** The total number of opens for a campaign. */
                        public var opens: Int?

                        /** The number of unique clicks. */
                        public var subscriberClicks: Int?

                        /** The number of unique opens. */
                        public var uniqueOpens: Int?

                        public init(clickRate: Double? = nil, clicks: Int? = nil, openRate: Double? = nil, opens: Int? = nil, subscriberClicks: Int? = nil, uniqueOpens: Int? = nil) {
                            self.clickRate = clickRate
                            self.clicks = clicks
                            self.openRate = openRate
                            self.opens = opens
                            self.subscriberClicks = subscriberClicks
                            self.uniqueOpens = uniqueOpens
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            clickRate = try container.decodeIfPresent("click_rate")
                            clicks = try container.decodeIfPresent("clicks")
                            openRate = try container.decodeIfPresent("open_rate")
                            opens = try container.decodeIfPresent("opens")
                            subscriberClicks = try container.decodeIfPresent("subscriber_clicks")
                            uniqueOpens = try container.decodeIfPresent("unique_opens")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(clickRate, forKey: "click_rate")
                            try container.encodeIfPresent(clicks, forKey: "clicks")
                            try container.encodeIfPresent(openRate, forKey: "open_rate")
                            try container.encodeIfPresent(opens, forKey: "opens")
                            try container.encodeIfPresent(subscriberClicks, forKey: "subscriber_clicks")
                            try container.encodeIfPresent(uniqueOpens, forKey: "unique_opens")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? ReportSummary else { return false }
                          guard self.clickRate == object.clickRate else { return false }
                          guard self.clicks == object.clicks else { return false }
                          guard self.openRate == object.openRate else { return false }
                          guard self.opens == object.opens else { return false }
                          guard self.subscriberClicks == object.subscriberClicks else { return false }
                          guard self.uniqueOpens == object.uniqueOpens else { return false }
                          return true
                        }

                        public static func == (lhs: ReportSummary, rhs: ReportSummary) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    /** The settings for the Automation workflow. */
                    public class Settings: APIModel {

                        /** Whether Mailchimp [authenticated](https://mailchimp.com/help/about-email-authentication/) the Automation. Defaults to `true`. */
                        public var authenticate: Bool?

                        /** Whether to automatically append Mailchimp's [default footer](https://mailchimp.com/help/about-campaign-footers/) to the Automation. */
                        public var autoFooter: Bool?

                        /** The 'from' name for the Automation (not an email address). */
                        public var fromName: String?

                        /** Whether to automatically inline the CSS included with the Automation content. */
                        public var inlineCss: Bool?

                        /** The reply-to email address for the Automation. */
                        public var replyTo: String?

                        /** The title of the Automation. */
                        public var title: String?

                        /** The Automation's custom 'To' name, typically the first name [audience field](https://mailchimp.com/help/getting-started-with-merge-tags/). */
                        public var toName: String?

                        /** Whether to use Mailchimp Conversation feature to manage replies */
                        public var useConversation: Bool?

                        public init(authenticate: Bool? = nil, autoFooter: Bool? = nil, fromName: String? = nil, inlineCss: Bool? = nil, replyTo: String? = nil, title: String? = nil, toName: String? = nil, useConversation: Bool? = nil) {
                            self.authenticate = authenticate
                            self.autoFooter = autoFooter
                            self.fromName = fromName
                            self.inlineCss = inlineCss
                            self.replyTo = replyTo
                            self.title = title
                            self.toName = toName
                            self.useConversation = useConversation
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            authenticate = try container.decodeIfPresent("authenticate")
                            autoFooter = try container.decodeIfPresent("auto_footer")
                            fromName = try container.decodeIfPresent("from_name")
                            inlineCss = try container.decodeIfPresent("inline_css")
                            replyTo = try container.decodeIfPresent("reply_to")
                            title = try container.decodeIfPresent("title")
                            toName = try container.decodeIfPresent("to_name")
                            useConversation = try container.decodeIfPresent("use_conversation")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(authenticate, forKey: "authenticate")
                            try container.encodeIfPresent(autoFooter, forKey: "auto_footer")
                            try container.encodeIfPresent(fromName, forKey: "from_name")
                            try container.encodeIfPresent(inlineCss, forKey: "inline_css")
                            try container.encodeIfPresent(replyTo, forKey: "reply_to")
                            try container.encodeIfPresent(title, forKey: "title")
                            try container.encodeIfPresent(toName, forKey: "to_name")
                            try container.encodeIfPresent(useConversation, forKey: "use_conversation")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Settings else { return false }
                          guard self.authenticate == object.authenticate else { return false }
                          guard self.autoFooter == object.autoFooter else { return false }
                          guard self.fromName == object.fromName else { return false }
                          guard self.inlineCss == object.inlineCss else { return false }
                          guard self.replyTo == object.replyTo else { return false }
                          guard self.title == object.title else { return false }
                          guard self.toName == object.toName else { return false }
                          guard self.useConversation == object.useConversation else { return false }
                          return true
                        }

                        public static func == (lhs: Settings, rhs: Settings) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    /** The tracking options for the Automation. */
                    public class Tracking: APIModel {

                        /** Deprecated */
                        public var capsule: Capsule?

                        /** The custom slug for [ClickTale](https://mailchimp.com/help/additional-tracking-options-for-campaigns/) tracking (max of 50 bytes). */
                        public var clicktale: String?

                        /** Whether to enable e-commerce tracking. */
                        public var ecomm360: Bool?

                        /** Deprecated */
                        public var goalTracking: Bool?

                        /** The custom slug for [Google Analytics](https://mailchimp.com/help/integrate-google-analytics-with-mailchimp/) tracking (max of 50 bytes). */
                        public var googleAnalytics: String?

                        /** Whether to [track clicks](https://mailchimp.com/help/enable-and-view-click-tracking/) in the HTML version of the Automation. Defaults to `true`. */
                        public var htmlClicks: Bool?

                        /** Whether to [track opens](https://mailchimp.com/help/about-open-tracking/). Defaults to `true`. */
                        public var opens: Bool?

                        /** Deprecated */
                        public var salesforce: Salesforce?

                        /** Whether to [track clicks](https://mailchimp.com/help/enable-and-view-click-tracking/) in the plain-text version of the Automation. Defaults to `true`. */
                        public var textClicks: Bool?

                        /** Deprecated */
                        public class Capsule: APIModel {

                            /** Update contact notes for a campaign based on a subscriber's email addresses. */
                            public var notes: Bool?

                            public init(notes: Bool? = nil) {
                                self.notes = notes
                            }

                            public required init(from decoder: Decoder) throws {
                                let container = try decoder.container(keyedBy: StringCodingKey.self)

                                notes = try container.decodeIfPresent("notes")
                            }

                            public func encode(to encoder: Encoder) throws {
                                var container = encoder.container(keyedBy: StringCodingKey.self)

                                try container.encodeIfPresent(notes, forKey: "notes")
                            }

                            public func isEqual(to object: Any?) -> Bool {
                              guard let object = object as? Capsule else { return false }
                              guard self.notes == object.notes else { return false }
                              return true
                            }

                            public static func == (lhs: Capsule, rhs: Capsule) -> Bool {
                                return lhs.isEqual(to: rhs)
                            }
                        }

                        /** Deprecated */
                        public class Salesforce: APIModel {

                            /** Create a campaign in a connected Salesforce account. */
                            public var campaign: Bool?

                            /** Update contact notes for a campaign based on a subscriber's email address. */
                            public var notes: Bool?

                            public init(campaign: Bool? = nil, notes: Bool? = nil) {
                                self.campaign = campaign
                                self.notes = notes
                            }

                            public required init(from decoder: Decoder) throws {
                                let container = try decoder.container(keyedBy: StringCodingKey.self)

                                campaign = try container.decodeIfPresent("campaign")
                                notes = try container.decodeIfPresent("notes")
                            }

                            public func encode(to encoder: Encoder) throws {
                                var container = encoder.container(keyedBy: StringCodingKey.self)

                                try container.encodeIfPresent(campaign, forKey: "campaign")
                                try container.encodeIfPresent(notes, forKey: "notes")
                            }

                            public func isEqual(to object: Any?) -> Bool {
                              guard let object = object as? Salesforce else { return false }
                              guard self.campaign == object.campaign else { return false }
                              guard self.notes == object.notes else { return false }
                              return true
                            }

                            public static func == (lhs: Salesforce, rhs: Salesforce) -> Bool {
                                return lhs.isEqual(to: rhs)
                            }
                        }

                        public init(capsule: Capsule? = nil, clicktale: String? = nil, ecomm360: Bool? = nil, goalTracking: Bool? = nil, googleAnalytics: String? = nil, htmlClicks: Bool? = nil, opens: Bool? = nil, salesforce: Salesforce? = nil, textClicks: Bool? = nil) {
                            self.capsule = capsule
                            self.clicktale = clicktale
                            self.ecomm360 = ecomm360
                            self.goalTracking = goalTracking
                            self.googleAnalytics = googleAnalytics
                            self.htmlClicks = htmlClicks
                            self.opens = opens
                            self.salesforce = salesforce
                            self.textClicks = textClicks
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            capsule = try container.decodeIfPresent("capsule")
                            clicktale = try container.decodeIfPresent("clicktale")
                            ecomm360 = try container.decodeIfPresent("ecomm360")
                            goalTracking = try container.decodeIfPresent("goal_tracking")
                            googleAnalytics = try container.decodeIfPresent("google_analytics")
                            htmlClicks = try container.decodeIfPresent("html_clicks")
                            opens = try container.decodeIfPresent("opens")
                            salesforce = try container.decodeIfPresent("salesforce")
                            textClicks = try container.decodeIfPresent("text_clicks")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encodeIfPresent(capsule, forKey: "capsule")
                            try container.encodeIfPresent(clicktale, forKey: "clicktale")
                            try container.encodeIfPresent(ecomm360, forKey: "ecomm360")
                            try container.encodeIfPresent(goalTracking, forKey: "goal_tracking")
                            try container.encodeIfPresent(googleAnalytics, forKey: "google_analytics")
                            try container.encodeIfPresent(htmlClicks, forKey: "html_clicks")
                            try container.encodeIfPresent(opens, forKey: "opens")
                            try container.encodeIfPresent(salesforce, forKey: "salesforce")
                            try container.encodeIfPresent(textClicks, forKey: "text_clicks")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? Tracking else { return false }
                          guard self.capsule == object.capsule else { return false }
                          guard self.clicktale == object.clicktale else { return false }
                          guard self.ecomm360 == object.ecomm360 else { return false }
                          guard self.goalTracking == object.goalTracking else { return false }
                          guard self.googleAnalytics == object.googleAnalytics else { return false }
                          guard self.htmlClicks == object.htmlClicks else { return false }
                          guard self.opens == object.opens else { return false }
                          guard self.salesforce == object.salesforce else { return false }
                          guard self.textClicks == object.textClicks else { return false }
                          return true
                        }

                        public static func == (lhs: Tracking, rhs: Tracking) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    /** Available triggers for Automation workflows. */
                    public class TriggerSettings: APIModel {

                        /** The type of Automation workflow. */
                        public enum WorkflowType: String, Codable, Equatable, CaseIterable {
                            case abandonedBrowse = "abandonedBrowse"
                            case abandonedCart = "abandonedCart"
                            case api = "api"
                            case bestCustomers = "bestCustomers"
                            case categoryFollowup = "categoryFollowup"
                            case dateAdded = "dateAdded"
                            case emailFollowup = "emailFollowup"
                            case emailSeries = "emailSeries"
                            case groupAdd = "groupAdd"
                            case groupRemove = "groupRemove"
                            case mandrill = "mandrill"
                            case productFollowup = "productFollowup"
                            case purchaseFollowup = "purchaseFollowup"
                            case recurringEvent = "recurringEvent"
                            case specialEvent = "specialEvent"
                            case visitUrl = "visitUrl"
                            case welcomeSeries = "welcomeSeries"
                        }

                        /** The type of Automation workflow. */
                        public var workflowType: WorkflowType

                        /** A workflow's runtime settings for an Automation. */
                        public var runtime: Runtime?

                        /** The number of emails in the Automation workflow. */
                        public var workflowEmailsCount: Int?

                        /** The title of the workflow type. */
                        public var workflowTitle: String?

                        /** A workflow's runtime settings for an Automation. */
                        public class Runtime: APIModel {

                            /** The days an Automation workflow can send. */
                            public enum Days: String, Codable, Equatable, CaseIterable {
                                case sunday = "sunday"
                                case monday = "monday"
                                case tuesday = "tuesday"
                                case wednesday = "wednesday"
                                case thursday = "thursday"
                                case friday = "friday"
                                case saturday = "saturday"
                            }

                            /** The days an Automation workflow can send. */
                            public var days: [Days]?

                            /** The hours an Automation workflow can send. */
                            public var hours: Hours?

                            /** The hours an Automation workflow can send. */
                            public class Hours: APIModel {

                                /** When to send the Automation email. */
                                public enum `Type`: String, Codable, Equatable, CaseIterable {
                                    case sendAsap = "send_asap"
                                    case sendBetween = "send_between"
                                    case sendAt = "send_at"
                                }

                                /** When to send the Automation email. */
                                public var type: `Type`

                                public init(type: `Type`) {
                                    self.type = type
                                }

                                public required init(from decoder: Decoder) throws {
                                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                                    type = try container.decode("type")
                                }

                                public func encode(to encoder: Encoder) throws {
                                    var container = encoder.container(keyedBy: StringCodingKey.self)

                                    try container.encode(type, forKey: "type")
                                }

                                public func isEqual(to object: Any?) -> Bool {
                                  guard let object = object as? Hours else { return false }
                                  guard self.type == object.type else { return false }
                                  return true
                                }

                                public static func == (lhs: Hours, rhs: Hours) -> Bool {
                                    return lhs.isEqual(to: rhs)
                                }
                            }

                            public init(days: [Days]? = nil, hours: Hours? = nil) {
                                self.days = days
                                self.hours = hours
                            }

                            public required init(from decoder: Decoder) throws {
                                let container = try decoder.container(keyedBy: StringCodingKey.self)

                                days = try container.decodeArrayIfPresent("days")
                                hours = try container.decodeIfPresent("hours")
                            }

                            public func encode(to encoder: Encoder) throws {
                                var container = encoder.container(keyedBy: StringCodingKey.self)

                                try container.encodeIfPresent(days, forKey: "days")
                                try container.encodeIfPresent(hours, forKey: "hours")
                            }

                            public func isEqual(to object: Any?) -> Bool {
                              guard let object = object as? Runtime else { return false }
                              guard self.days == object.days else { return false }
                              guard self.hours == object.hours else { return false }
                              return true
                            }

                            public static func == (lhs: Runtime, rhs: Runtime) -> Bool {
                                return lhs.isEqual(to: rhs)
                            }
                        }

                        public init(workflowType: WorkflowType, runtime: Runtime? = nil, workflowEmailsCount: Int? = nil, workflowTitle: String? = nil) {
                            self.workflowType = workflowType
                            self.runtime = runtime
                            self.workflowEmailsCount = workflowEmailsCount
                            self.workflowTitle = workflowTitle
                        }

                        public required init(from decoder: Decoder) throws {
                            let container = try decoder.container(keyedBy: StringCodingKey.self)

                            workflowType = try container.decode("workflow_type")
                            runtime = try container.decodeIfPresent("runtime")
                            workflowEmailsCount = try container.decodeIfPresent("workflow_emails_count")
                            workflowTitle = try container.decodeIfPresent("workflow_title")
                        }

                        public func encode(to encoder: Encoder) throws {
                            var container = encoder.container(keyedBy: StringCodingKey.self)

                            try container.encode(workflowType, forKey: "workflow_type")
                            try container.encodeIfPresent(runtime, forKey: "runtime")
                            try container.encodeIfPresent(workflowEmailsCount, forKey: "workflow_emails_count")
                            try container.encodeIfPresent(workflowTitle, forKey: "workflow_title")
                        }

                        public func isEqual(to object: Any?) -> Bool {
                          guard let object = object as? TriggerSettings else { return false }
                          guard self.workflowType == object.workflowType else { return false }
                          guard self.runtime == object.runtime else { return false }
                          guard self.workflowEmailsCount == object.workflowEmailsCount else { return false }
                          guard self.workflowTitle == object.workflowTitle else { return false }
                          return true
                        }

                        public static func == (lhs: TriggerSettings, rhs: TriggerSettings) -> Bool {
                            return lhs.isEqual(to: rhs)
                        }
                    }

                    public init(links: [Links]? = nil, createTime: DateTime? = nil, emailsSent: Int? = nil, id: String? = nil, recipients: Recipients? = nil, reportSummary: ReportSummary? = nil, settings: Settings? = nil, startTime: DateTime? = nil, status: Status? = nil, tracking: Tracking? = nil, triggerSettings: TriggerSettings? = nil) {
                        self.links = links
                        self.createTime = createTime
                        self.emailsSent = emailsSent
                        self.id = id
                        self.recipients = recipients
                        self.reportSummary = reportSummary
                        self.settings = settings
                        self.startTime = startTime
                        self.status = status
                        self.tracking = tracking
                        self.triggerSettings = triggerSettings
                    }

                    public required init(from decoder: Decoder) throws {
                        let container = try decoder.container(keyedBy: StringCodingKey.self)

                        links = try container.decodeArrayIfPresent("_links")
                        createTime = try container.decodeIfPresent("create_time")
                        emailsSent = try container.decodeIfPresent("emails_sent")
                        id = try container.decodeIfPresent("id")
                        recipients = try container.decodeIfPresent("recipients")
                        reportSummary = try container.decodeIfPresent("report_summary")
                        settings = try container.decodeIfPresent("settings")
                        startTime = try container.decodeIfPresent("start_time")
                        status = try container.decodeIfPresent("status")
                        tracking = try container.decodeIfPresent("tracking")
                        triggerSettings = try container.decodeIfPresent("trigger_settings")
                    }

                    public func encode(to encoder: Encoder) throws {
                        var container = encoder.container(keyedBy: StringCodingKey.self)

                        try container.encodeIfPresent(links, forKey: "_links")
                        try container.encodeIfPresent(createTime, forKey: "create_time")
                        try container.encodeIfPresent(emailsSent, forKey: "emails_sent")
                        try container.encodeIfPresent(id, forKey: "id")
                        try container.encodeIfPresent(recipients, forKey: "recipients")
                        try container.encodeIfPresent(reportSummary, forKey: "report_summary")
                        try container.encodeIfPresent(settings, forKey: "settings")
                        try container.encodeIfPresent(startTime, forKey: "start_time")
                        try container.encodeIfPresent(status, forKey: "status")
                        try container.encodeIfPresent(tracking, forKey: "tracking")
                        try container.encodeIfPresent(triggerSettings, forKey: "trigger_settings")
                    }

                    public func isEqual(to object: Any?) -> Bool {
                      guard let object = object as? Automations else { return false }
                      guard self.links == object.links else { return false }
                      guard self.createTime == object.createTime else { return false }
                      guard self.emailsSent == object.emailsSent else { return false }
                      guard self.id == object.id else { return false }
                      guard self.recipients == object.recipients else { return false }
                      guard self.reportSummary == object.reportSummary else { return false }
                      guard self.settings == object.settings else { return false }
                      guard self.startTime == object.startTime else { return false }
                      guard self.status == object.status else { return false }
                      guard self.tracking == object.tracking else { return false }
                      guard self.triggerSettings == object.triggerSettings else { return false }
                      return true
                    }

                    public static func == (lhs: Automations, rhs: Automations) -> Bool {
                        return lhs.isEqual(to: rhs)
                    }
                }

                public init(links: [Links]? = nil, automations: [Automations]? = nil, totalItems: Int? = nil) {
                    self.links = links
                    self.automations = automations
                    self.totalItems = totalItems
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    links = try container.decodeArrayIfPresent("_links")
                    automations = try container.decodeArrayIfPresent("automations")
                    totalItems = try container.decodeIfPresent("total_items")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encodeIfPresent(links, forKey: "_links")
                    try container.encodeIfPresent(automations, forKey: "automations")
                    try container.encodeIfPresent(totalItems, forKey: "total_items")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? Status200 else { return false }
                  guard self.links == object.links else { return false }
                  guard self.automations == object.automations else { return false }
                  guard self.totalItems == object.totalItems else { return false }
                  return true
                }

                public static func == (lhs: Status200, rhs: Status200) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }

            /** An error generated by the Mailchimp API. Conforms to IETF draft 'draft-nottingham-http-problem-06'. */
            public class DefaultResponse: APIModel {

                /** A human-readable explanation specific to this occurrence of the problem. [Learn more about errors](/developer/guides/get-started-with-mailchimp-api-3/#Errors). */
                public var detail: String

                /** A string that identifies this specific occurrence of the problem. Please provide this ID when contacting support. */
                public var instance: String

                /** The HTTP status code (RFC2616, Section 6) generated by the origin server for this occurrence of the problem. */
                public var status: Int

                /** A short, human-readable summary of the problem type. It shouldn't change based on the occurrence of the problem, except for purposes of localization. */
                public var title: String

                /** An absolute URI that identifies the problem type. When dereferenced, it should provide human-readable documentation for the problem type. */
                public var type: String

                public init(detail: String, instance: String, status: Int, title: String, type: String) {
                    self.detail = detail
                    self.instance = instance
                    self.status = status
                    self.title = title
                    self.type = type
                }

                public required init(from decoder: Decoder) throws {
                    let container = try decoder.container(keyedBy: StringCodingKey.self)

                    detail = try container.decode("detail")
                    instance = try container.decode("instance")
                    status = try container.decode("status")
                    title = try container.decode("title")
                    type = try container.decode("type")
                }

                public func encode(to encoder: Encoder) throws {
                    var container = encoder.container(keyedBy: StringCodingKey.self)

                    try container.encode(detail, forKey: "detail")
                    try container.encode(instance, forKey: "instance")
                    try container.encode(status, forKey: "status")
                    try container.encode(title, forKey: "title")
                    try container.encode(type, forKey: "type")
                }

                public func isEqual(to object: Any?) -> Bool {
                  guard let object = object as? DefaultResponse else { return false }
                  guard self.detail == object.detail else { return false }
                  guard self.instance == object.instance else { return false }
                  guard self.status == object.status else { return false }
                  guard self.title == object.title else { return false }
                  guard self.type == object.type else { return false }
                  return true
                }

                public static func == (lhs: DefaultResponse, rhs: DefaultResponse) -> Bool {
                    return lhs.isEqual(to: rhs)
                }
            }
            public typealias SuccessType = Status200
            case status200(Status200)

            /** An error generated by the Mailchimp API. */
            case defaultResponse(statusCode: Int, DefaultResponse)

            public var success: Status200? {
                switch self {
                case .status200(let response): return response
                default: return nil
                }
            }

            public var failure: DefaultResponse? {
                switch self {
                case .defaultResponse(_, let response): return response
                default: return nil
                }
            }

            /// either success or failure value. Success is anything in the 200..<300 status code range
            public var responseResult: APIResponseResult<Status200, DefaultResponse> {
                if let successValue = success {
                    return .success(successValue)
                } else if let failureValue = failure {
                    return .failure(failureValue)
                } else {
                    fatalError("Response does not have success or failure response")
                }
            }

            public var response: Any {
                switch self {
                case .status200(let response): return response
                case .defaultResponse(_, let response): return response
                }
            }

            public var statusCode: Int {
                switch self {
                case .status200: return 200
                case .defaultResponse(let statusCode, _): return statusCode
                }
            }

            public var successful: Bool {
                switch self {
                case .status200: return true
                case .defaultResponse: return false
                }
            }

            public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
                switch statusCode {
                case 200: self = try .status200(decoder.decode(Status200.self, from: data))
                default: self = try .defaultResponse(statusCode: statusCode, decoder.decode(DefaultResponse.self, from: data))
                }
            }

            public var description: String {
                return "\(statusCode) \(successful ? "success" : "failure")"
            }

            public var debugDescription: String {
                var string = description
                let responseString = "\(response)"
                if responseString != "()" {
                    string += "\n\(responseString)"
                }
                return string
            }
        }
    }
}
