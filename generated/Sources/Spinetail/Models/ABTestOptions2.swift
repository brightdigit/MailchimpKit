//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

import PrchModel
/** The settings specific to A/B test campaigns. */
public struct ABTestOptions2: Codable, Equatable, Content {

    /** The combination that performs the best. This may be determined automatically by click rate, open rate, or total revenue -- or you may choose manually based on the reporting data you find the most valuable. For Multivariate Campaigns testing send_time, winner_criteria is ignored. For Multivariate Campaigns with 'manual' as the winner_criteria, the winner must be chosen in the Mailchimp web application. */
    public enum WinnerCriteria: String, Codable, Equatable, CaseIterable {
        case opens = "opens"
        case clicks = "clicks"
        case manual = "manual"
        case totalRevenue = "total_revenue"
    }

    /** The combination that performs the best. This may be determined automatically by click rate, open rate, or total revenue -- or you may choose manually based on the reporting data you find the most valuable. For Multivariate Campaigns testing send_time, winner_criteria is ignored. For Multivariate Campaigns with 'manual' as the winner_criteria, the winner must be chosen in the Mailchimp web application. */
    public var winnerCriteria: WinnerCriteria

    /** Combinations of possible variables used to build emails. */
    public var combinations: [CombinationsInner]?

    /** Descriptions of possible email contents. To set campaign contents, make a PUT request to /campaigns/{campaign_id}/content with the field 'variate_contents'. */
    public var contents: [String]?

    /** The possible from names. The number of from_names provided must match the number of reply_to_addresses. If no from_names are provided, settings.from_name will be used. */
    public var fromNames: [String]?

    /** The possible reply-to addresses. The number of reply_to_addresses provided must match the number of from_names. If no reply_to_addresses are provided, settings.reply_to will be used. */
    public var replyToAddresses: [String]?

    /** The possible send times to test. The times provided should be in the format YYYY-MM-DD HH:MM:SS. If send_times are provided to test, the test_size will be set to 100% and winner_criteria will be ignored. */
    public var sendTimes: [DateTime]?

    /** The possible subject lines to test. If no subject lines are provided, settings.subject_line will be used. */
    public var subjectLines: [String]?

    /** The percentage of recipients to send the test combinations to, must be a value between 10 and 100. */
    public var testSize: Int?

    /** The number of minutes to wait before choosing the winning campaign. The value of wait_time must be greater than 0 and in whole hours, specified in minutes. */
    public var waitTime: Int?

    /** ID of the campaign that was sent to the remaining recipients based on the winning combination. */
    public var winningCampaignId: String?

    /** ID for the winning combination. */
    public var winningCombinationId: String?

    public init(winnerCriteria: WinnerCriteria, combinations: [CombinationsInner]? = nil, contents: [String]? = nil, fromNames: [String]? = nil, replyToAddresses: [String]? = nil, sendTimes: [DateTime]? = nil, subjectLines: [String]? = nil, testSize: Int? = nil, waitTime: Int? = nil, winningCampaignId: String? = nil, winningCombinationId: String? = nil) {
        self.winnerCriteria = winnerCriteria
        self.combinations = combinations
        self.contents = contents
        self.fromNames = fromNames
        self.replyToAddresses = replyToAddresses
        self.sendTimes = sendTimes
        self.subjectLines = subjectLines
        self.testSize = testSize
        self.waitTime = waitTime
        self.winningCampaignId = winningCampaignId
        self.winningCombinationId = winningCombinationId
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        winnerCriteria = try container.decode("winner_criteria")
        combinations = try container.decodeArrayIfPresent("combinations")
        contents = try container.decodeArrayIfPresent("contents")
        fromNames = try container.decodeArrayIfPresent("from_names")
        replyToAddresses = try container.decodeArrayIfPresent("reply_to_addresses")
        sendTimes = try container.decodeArrayIfPresent("send_times")
        subjectLines = try container.decodeArrayIfPresent("subject_lines")
        testSize = try container.decodeIfPresent("test_size")
        waitTime = try container.decodeIfPresent("wait_time")
        winningCampaignId = try container.decodeIfPresent("winning_campaign_id")
        winningCombinationId = try container.decodeIfPresent("winning_combination_id")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encode(winnerCriteria, forKey: "winner_criteria")
        try container.encodeIfPresent(combinations, forKey: "combinations")
        try container.encodeIfPresent(contents, forKey: "contents")
        try container.encodeIfPresent(fromNames, forKey: "from_names")
        try container.encodeIfPresent(replyToAddresses, forKey: "reply_to_addresses")
        try container.encodeIfPresent(sendTimes, forKey: "send_times")
        try container.encodeIfPresent(subjectLines, forKey: "subject_lines")
        try container.encodeIfPresent(testSize, forKey: "test_size")
        try container.encodeIfPresent(waitTime, forKey: "wait_time")
        try container.encodeIfPresent(winningCampaignId, forKey: "winning_campaign_id")
        try container.encodeIfPresent(winningCombinationId, forKey: "winning_combination_id")
    }

}
