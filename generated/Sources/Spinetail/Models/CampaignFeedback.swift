//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

import PrchModel
/** A specific feedback message from a specific campaign. */
public struct CampaignFeedback: Codable, Equatable, Content {

    /** The source of the feedback. */
    public enum Source: String, Codable, Equatable, CaseIterable {
        case api = "api"
        case email = "email"
        case sms = "sms"
        case web = "web"
        case ios = "ios"
        case android = "android"
    }

    /** The content of the feedback. */
    public var message: String

    /** A list of link types and descriptions for the API schema documents. */
    public var links: [ResourceLink]?

    /** The block id for the editable block that the feedback addresses. */
    public var blockId: Int?

    /** The unique id for the campaign. */
    public var campaignId: String?

    /** The date and time the feedback item was created in ISO 8601 format. */
    public var createdAt: DateTime?

    /** The login name of the user who created the feedback. */
    public var createdBy: String?

    /** The individual id for the feedback item. */
    public var feedbackId: Int?

    /** The status of feedback. */
    public var isComplete: Bool?

    /** If a reply, the id of the parent feedback item. */
    public var parentId: Int?

    /** The source of the feedback. */
    public var source: Source?

    /** The date and time the feedback was last updated in ISO 8601 format. */
    public var updatedAt: DateTime?

    public init(message: String, links: [ResourceLink]? = nil, blockId: Int? = nil, campaignId: String? = nil, createdAt: DateTime? = nil, createdBy: String? = nil, feedbackId: Int? = nil, isComplete: Bool? = nil, parentId: Int? = nil, source: Source? = nil, updatedAt: DateTime? = nil) {
        self.message = message
        self.links = links
        self.blockId = blockId
        self.campaignId = campaignId
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.feedbackId = feedbackId
        self.isComplete = isComplete
        self.parentId = parentId
        self.source = source
        self.updatedAt = updatedAt
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        message = try container.decode("message")
        links = try container.decodeArrayIfPresent("_links")
        blockId = try container.decodeIfPresent("block_id")
        campaignId = try container.decodeIfPresent("campaign_id")
        createdAt = try container.decodeIfPresent("created_at")
        createdBy = try container.decodeIfPresent("created_by")
        feedbackId = try container.decodeIfPresent("feedback_id")
        isComplete = try container.decodeIfPresent("is_complete")
        parentId = try container.decodeIfPresent("parent_id")
        source = try container.decodeIfPresent("source")
        updatedAt = try container.decodeIfPresent("updated_at")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encode(message, forKey: "message")
        try container.encodeIfPresent(links, forKey: "_links")
        try container.encodeIfPresent(blockId, forKey: "block_id")
        try container.encodeIfPresent(campaignId, forKey: "campaign_id")
        try container.encodeIfPresent(createdAt, forKey: "created_at")
        try container.encodeIfPresent(createdBy, forKey: "created_by")
        try container.encodeIfPresent(feedbackId, forKey: "feedback_id")
        try container.encodeIfPresent(isComplete, forKey: "is_complete")
        try container.encodeIfPresent(parentId, forKey: "parent_id")
        try container.encodeIfPresent(source, forKey: "source")
        try container.encodeIfPresent(updatedAt, forKey: "updated_at")
    }

}
