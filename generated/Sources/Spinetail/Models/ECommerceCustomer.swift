//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

import PrchModel
/** Information about a specific customer. */
public struct ECommerceCustomer: Codable, Equatable, Content {

    /** A list of link types and descriptions for the API schema documents. */
    public var links: [ResourceLink]?

    public var address: Address?

    /** The customer's company. */
    public var company: String?

    /** The date and time the customer was created in ISO 8601 format. */
    public var createdAt: DateTime?

    /** The customer's email address. */
    public var emailAddress: String?

    /** The customer's first name. */
    public var firstName: String?

    /** A unique identifier for the customer. */
    public var id: String?

    /** The customer's last name. */
    public var lastName: String?

    /** The customer's opt-in status. This value will never overwrite the opt-in status of a pre-existing Mailchimp list member, but will apply to list members that are added through the e-commerce API endpoints. Customers who don't opt in to your Mailchimp list [will be added as `Transactional` members](https://mailchimp.com/developer/marketing/docs/e-commerce/#customers). */
    public var optInStatus: Bool?

    /** The customer's total order count. */
    public var ordersCount: Int?

    /** The total amount the customer has spent. */
    public var totalSpent: Double?

    /** The date and time the customer was last updated in ISO 8601 format. */
    public var updatedAt: DateTime?

    public init(links: [ResourceLink]? = nil, address: Address? = nil, company: String? = nil, createdAt: DateTime? = nil, emailAddress: String? = nil, firstName: String? = nil, id: String? = nil, lastName: String? = nil, optInStatus: Bool? = nil, ordersCount: Int? = nil, totalSpent: Double? = nil, updatedAt: DateTime? = nil) {
        self.links = links
        self.address = address
        self.company = company
        self.createdAt = createdAt
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.id = id
        self.lastName = lastName
        self.optInStatus = optInStatus
        self.ordersCount = ordersCount
        self.totalSpent = totalSpent
        self.updatedAt = updatedAt
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        links = try container.decodeArrayIfPresent("_links")
        address = try container.decodeIfPresent("address")
        company = try container.decodeIfPresent("company")
        createdAt = try container.decodeIfPresent("created_at")
        emailAddress = try container.decodeIfPresent("email_address")
        firstName = try container.decodeIfPresent("first_name")
        id = try container.decodeIfPresent("id")
        lastName = try container.decodeIfPresent("last_name")
        optInStatus = try container.decodeIfPresent("opt_in_status")
        ordersCount = try container.decodeIfPresent("orders_count")
        totalSpent = try container.decodeIfPresent("total_spent")
        updatedAt = try container.decodeIfPresent("updated_at")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(links, forKey: "_links")
        try container.encodeIfPresent(address, forKey: "address")
        try container.encodeIfPresent(company, forKey: "company")
        try container.encodeIfPresent(createdAt, forKey: "created_at")
        try container.encodeIfPresent(emailAddress, forKey: "email_address")
        try container.encodeIfPresent(firstName, forKey: "first_name")
        try container.encodeIfPresent(id, forKey: "id")
        try container.encodeIfPresent(lastName, forKey: "last_name")
        try container.encodeIfPresent(optInStatus, forKey: "opt_in_status")
        try container.encodeIfPresent(ordersCount, forKey: "orders_count")
        try container.encodeIfPresent(totalSpent, forKey: "total_spent")
        try container.encodeIfPresent(updatedAt, forKey: "updated_at")
    }

}
